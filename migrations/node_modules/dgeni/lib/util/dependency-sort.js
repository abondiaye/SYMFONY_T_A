"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortByDependency = void 0;
var dependency_graph_1 = require("dependency-graph");
/**
 * @name  sortByDependency
 * @description                         Sort a collection of items, such that the items come before
 *                                      or after the dependencies defined on the items.
 * @param  {Array|Object}  items        The collection of items to sort.
 * @param  {string} [afterProp]         The name of the property that will hold an array of names of
 *                                      other items that the item must come after. If it is not
 *                                      defined then this property is ignored.
 * @param  {string} [beforeProp]        The name of the property that will hold an array of names of
 *                                      other items that the item must come before. If it is not
 *                                      defined then this property is ignored.
 * @param  {string} [nameProp='name']   The name of the property on the object that holds its name,
 *                                      defaults to 'name'.
 * @return {Array}                      A new array containing the sorted collection of items.
 */
function sortByDependency(items, afterProp, beforeProp, nameProp) {
    if (nameProp === void 0) { nameProp = 'name'; }
    var map = {};
    var depGraph = new dependency_graph_1.DepGraph();
    function addDependencies(item, dependencyProp, addBefore) {
        if (addBefore === void 0) { addBefore = false; }
        if (dependencyProp && item[dependencyProp]) {
            if (!Array.isArray(item[dependencyProp])) {
                throw new Error('Error in item "' + item[nameProp] + '" - ' + dependencyProp + ' must be an array');
            }
            item[dependencyProp].forEach(function (dependency) {
                if (!map[dependency]) {
                    throw new Error('Missing dependency: "' + dependency + '"  on "' + item[nameProp] + '"');
                }
                if (addBefore) {
                    depGraph.addDependency(dependency, item[nameProp]);
                }
                else {
                    depGraph.addDependency(item[nameProp], dependency);
                }
            });
        }
    }
    Object.keys(items).forEach(function (itemKey) {
        var item = items[itemKey];
        if (!item[nameProp]) {
            throw new Error('Missing ' + nameProp + ' property on item ' + itemKey);
        }
        map[item[nameProp]] = item;
        depGraph.addNode(item[nameProp]);
    });
    Object.values(items).forEach(function (item) {
        addDependencies(item, afterProp);
        addDependencies(item, beforeProp, true);
    });
    return depGraph.overallOrder().map(function (itemName) { return map[itemName]; });
}
exports.sortByDependency = sortByDependency;
;
//# sourceMappingURL=dependency-sort.js.map